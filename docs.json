[{"name":"SafeParser","comment":"\n\n\n## Running parsers\n\n@docs Parser, run, toElmParser\n\n\n## Chomping inputs\n\n@docs OneOrMore, ZeroOrMore, chompIf, chompWhile, getChompedString, mapChompedString\n\n\n## Generally useful parsers\n\n@docs spaces, symbol, token, keyword, variable, end\n\n\n## Metadata parsers\n\n@docs getOffset\n\n\n## Succeeding and failing\n\n@docs succeed, problem\n\n\n## Combining parsers\n\n@docs keep1, keep0, skip1, skip0\n\n\n## Choosing parsers\n\n@docs oneOf, or, commit, backtrackable\n\n\n## Transforming parsers\n\n@docs map, andThen00, andThen10, andThen01\n\n\n## Looping parsers\n\n@docs Step, continue, done, loop\n\n","unions":[{"name":"OneOrMore","comment":" A phantom type indicating that a `Parser` is guaranteed to chomp at least\none character when it succeeds.\n","args":[],"cases":[]},{"name":"Parser","comment":" Very similar to `elm/parser`'s `Parser` type, but with an extra phantom type\nvariable that allows us to track and propagate information about whether the\nparser is guaranteed to chomp characters when it succeeds.\n","args":["any","a"],"cases":[]},{"name":"ZeroOrMore","comment":" A phantom type indicating that a `Parser` might succeed without chomping any\ncharacters.\n","args":[],"cases":[]}],"aliases":[{"name":"Step","comment":" Instead of directly exposing the `elm/parser` constructors for `Step`\n(`Loop` and `Done`), we provide two functions, `continue` and `done` that are\nequivalent to `map Loop` and `map Done`.\n","args":["state","a"],"type":"Parser.Step state a"}],"values":[{"name":"andThen00","comment":" Like [`elm/parser`'s\n`andThen`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#andThen).\nGo read those docs!\n\n`andThen00` is used when the parser returned by the callback in the first\nargument is `ZeroOrMore`, and the parser passed as the second argument is _also_\n`ZeroOrMore`. Since neither of these parsers is guaranteed to chomp any\ncharacters, `andThen00` returns a `ZeroOrMore` parser.\n\n","type":"(a -> SafeParser.Parser SafeParser.ZeroOrMore b) -> SafeParser.Parser SafeParser.ZeroOrMore a -> SafeParser.Parser SafeParser.ZeroOrMore b"},{"name":"andThen01","comment":" Like [`elm/parser`'s\n`andThen`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#andThen).\nGo read those docs!\n\n`andThen01` is used when the parser that results from the callback in the first\nargument is `OneOrMore`. This guarantees that if the parser succeeds, it must\nchomp one or more characters, so `andThen01` can return a `OneOrMore` parser.\n\n","type":"(a -> SafeParser.Parser SafeParser.OneOrMore b) -> SafeParser.Parser any a -> SafeParser.Parser oneOrMore b"},{"name":"andThen10","comment":" Like [`elm/parser`'s\n`andThen`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#andThen).\nGo read those docs!\n\n`andThen10` is used when the parser passed as the second argument is\n`OneOrMore`. This guarantees that if the parser succeeds, it must chomp one or\nmore characters, so `andThen10` can return a `OneOrMore` parser.\n\n","type":"(a -> SafeParser.Parser any b) -> SafeParser.Parser SafeParser.OneOrMore a -> SafeParser.Parser oneOrMore b"},{"name":"backtrackable","comment":" Like [`elm/parser`'s\n`backtrackable`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#backtrackable).\nGo read those docs!\n","type":"SafeParser.Parser any a -> SafeParser.Parser any a"},{"name":"chompIf","comment":" Chomp one character if it passes the test.\n\n    import SafeParser as SP\n\n    chompUpper : SP.Parser oneOrMore ()\n    chompUpper =\n        SP.chompIf Char.isUpper\n\n    SP.run chompUpper \"T\" --> Ok ()\n\nSo this can chomp a character like `\"T\"` and produces a `()` value.\n\n","type":"(Char.Char -> Basics.Bool) -> SafeParser.Parser oneOrMore ()"},{"name":"chompWhile","comment":" Chomp zero or more characters if they pass the test. This is commonly\nuseful for chomping whitespace or variable names:\n\n    import SafeParser as SP\n\n    elmVar : SP.Parser oneOrMore String\n    elmVar =\n        SP.succeed identity\n            |> SP.keep1 (SP.chompIf Char.isLower)\n            |> SP.skip0 (SP.chompWhile (\\c -> Char.isAlphaNum c || c == '_'))\n            |> SP.getChompedString\n\n    SP.run elmVar \"helloWorld\" --> Ok \"helloWorld\"\n\nNote: a `chompWhile` parser always succeeds!\n\n","type":"(Char.Char -> Basics.Bool) -> SafeParser.Parser SafeParser.ZeroOrMore ()"},{"name":"commit","comment":" Like [`elm/parser`'s\n`commit`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#commit).\nGo read those docs!\n","type":"a -> SafeParser.Parser any a"},{"name":"continue","comment":" Ensure that any parser that is going to continue looping is always going to\nchomp something if it succeeds. This makes it impossible to fall into infinite\nloops.\n","type":"SafeParser.Parser SafeParser.OneOrMore state -> SafeParser.Parser any (SafeParser.Step state a)"},{"name":"done","comment":" For parsers that end a loop, it doesn't matter if they chomp or not - either\nway, there's no risk of an infinite loop. So you can pass any parser to `done`.\n","type":"SafeParser.Parser any a -> SafeParser.Parser any (SafeParser.Step state a)"},{"name":"end","comment":" Check if you have reached the end of the string you are parsing.\n\n    import SafeParser as SP\n    import Parser as P\n\n    oneNumber : SP.Parser oneOrMore String\n    oneNumber =\n        SP.succeed ()\n            |> SP.skip1 (SP.chompIf (Char.isDigit))\n            |> SP.skip0 (SP.chompWhile (Char.isDigit))\n            |> SP.getChompedString\n\n    justOneNumber : SP.Parser oneOrMore String\n    justOneNumber =\n        SP.succeed identity\n            |> SP.keep1 oneNumber\n            |> SP.skip1 SP.end\n\n    SP.run justOneNumber \"90210\" --> Ok \"90210\"\n    SP.run justOneNumber \"1 + 2\" --> Err [ { col = 2, problem = P.ExpectingEnd, row = 1 } ]\n    SP.run oneNumber     \"1 + 2\" --> Ok \"1\"\n\nParsers can succeed without parsing the whole string. Ending your parser with end guarantees that you have successfully parsed the whole string.\n\n","type":"SafeParser.Parser oneOrMore ()"},{"name":"getChompedString","comment":" Like [`elm/parser`'s\n`getChompedString`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#getChompedString).\nGo read those docs!\n","type":"SafeParser.Parser any a -> SafeParser.Parser any String.String"},{"name":"getOffset","comment":" Like [`elm/parser`'s\n`getOffset`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#getOffset).\nGo read those docs!\n","type":"SafeParser.Parser SafeParser.ZeroOrMore Basics.Int"},{"name":"keep0","comment":" Keep values produced by a `ZeroOrMore` parser in a parser pipeline.\n\nSee docs for [`keep1`](#keep1).\n\n","type":"SafeParser.Parser SafeParser.ZeroOrMore a -> SafeParser.Parser any (a -> b) -> SafeParser.Parser any b"},{"name":"keep1","comment":" Keep values produced by a `OneOrMore` parser in a parser pipeline.\n\nFor example, we could say:\n\n    import SafeParser as SP\n\n    type alias Point =\n        { x : Int, y : Int }\n\n    int : SP.Parser SP.OneOrMore Int\n    int =\n        SP.succeed (++)\n            |> SP.keep1\n                (SP.chompIf Char.isDigit\n                    |> SP.getChompedString\n                )\n            |> SP.keep0\n                (SP.chompWhile Char.isDigit\n                    |> SP.getChompedString\n                )\n            |> SP.andThen10\n                (\\str ->\n                    case String.toInt str of\n                        Just n ->\n                            SP.succeed n\n\n                        Nothing ->\n                            SP.problem \"not an int\"\n                )\n\n    point : SP.Parser SP.OneOrMore Point\n    point =\n        SP.succeed Point\n            |> SP.skip0 (SP.symbol \"(\")\n            |> SP.keep1 int\n            |> SP.skip0 (SP.symbol \",\")\n            |> SP.keep1 int\n            |> SP.skip0 (SP.symbol \")\")\n\n    SP.run point \"(123,456)\" --> Ok { x = 123, y = 456 }\n\nAll the parsers in the `point` pipeline will chomp characters and produce\nvalues. So `symbol \"(\"` will chomp one paren and produce a `()` value.\nSimilarly, `int` will chomp some digits and produce an `Int` value. The\n`keep1`/`keep0` and `skip1`/`skip0` functions just decide whether we give the\nvalues to the Point function.\n\nSo in this case, we skip the `()` from `symbol \"(\"`, we keep the `Int` from\n`int`, etc.\n\n","type":"SafeParser.Parser SafeParser.OneOrMore a -> SafeParser.Parser any (a -> b) -> SafeParser.Parser oneOrMore b"},{"name":"keyword","comment":" Parse keywords like `let`, `case`, and `type`.\n\n    import SafeParser as SP\n    import Parser as P\n\n    SP.run (SP.keyword \"let\") \"let\" --> Ok ()\n    SP.run (SP.keyword \"let\") \"var\" --> Err [ { col = 1, problem = P.ExpectingKeyword \"let\", row = 1 } ]\n    SP.run (SP.keyword \"let\") \"letters\" --> Err [ { col = 1, problem = P.ExpectingKeyword \"let\", row = 1 } ]\n\nNote: Notice the third case there! `keyword` actually looks ahead one character to\nmake sure it is not a letter, number, or underscore. The goal is to help with\nparsers like this:\n\n    import SafeParser as SP\n\n    elmVar : SP.Parser oneOrMore String\n    elmVar =\n        SP.succeed identity\n            |> SP.keep1 (SP.chompIf Char.isLower)\n            |> SP.skip0 (SP.chompWhile (\\c -> Char.isAlphaNum c || c == '_'))\n            |> SP.getChompedString\n\n    letBinding =\n        SP.succeed identity\n            |> SP.skip1 (SP.keyword \"let\")\n            |> SP.skip0 SP.spaces\n            |> SP.keep1 elmVar\n            |> SP.skip0 SP.spaces\n            |> SP.skip1 (SP.symbol \"=\")\n\n    SP.run letBinding \"let x =\"\n    --> Ok \"x\"\n\nThe trouble is that `spaces` may chomp zero characters (to handle expressions like\n`[1,2]` and `[ 1 , 2 ]`) and in this case, it would mean `letters` could be parsed as\n`let ters` and then wonder where the equals sign is! Check out the token docs if\nyou need to customize this!\n\n","type":"String.String -> SafeParser.Parser oneOrMore ()"},{"name":"loop","comment":" Run the first callback with the initial state and if it succeeds, either\ncontinue the loop or return a value. If the first callback fails, run the second\ncallback and either continue or return a value.\n\n    import SafeParser as SP\n\n    digits =\n        SP.loop\n            ()\n            (\\state ->\n                (SP.chompIf Char.isDigit |> SP.continue)\n                    |> SP.or (SP.succeed () |> SP.done)\n            )\n            |> SP.getChompedString\n\n    SP.run digits \"1234abc\" --> Ok \"1234\"\n\n","type":"state -> (state -> SafeParser.Parser any (SafeParser.Step state a)) -> SafeParser.Parser any a"},{"name":"map","comment":" Like [`elm/parser`'s\n`map`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#map). Go\nread those docs!\n","type":"(a -> b) -> SafeParser.Parser any a -> SafeParser.Parser any b"},{"name":"mapChompedString","comment":" Like [`elm/parser`'s\n`mapChompedString`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#mapChompedString).\nGo read those docs!\n","type":"(String.String -> a -> b) -> SafeParser.Parser any a -> SafeParser.Parser any b"},{"name":"oneOf","comment":" Take a list of `OneOrMore` parsers and try them one after the other until\none of them succeeds.\n\n    import SafeParser as SP\n    import Parser as P\n\n    bool : SP.Parser oneOrMore Bool\n    bool =\n        SP.oneOf\n            [ SP.symbol \"true\" |> SP.map (\\_ -> True)\n            , SP.symbol \"false\" |> SP.map (\\_ -> False)\n            ]\n\n    SP.run bool \"true\" --> Ok True\n    SP.run bool \"tru\" --> Err [ { col = 1, problem = ExpectingSymbol \"true\", row = 1 }, { col = 1, problem = P.ExpectingSymbol \"false\", row = 1 } ]\n    SP.run (SP.oneOf []) \"a\" --> Err [ { col = 1, problem = P.Problem \"The `oneOf` parser should be passed a list of at least two parsers\", row = 1 } ]\n\n","type":"List.List (SafeParser.Parser SafeParser.OneOrMore a) -> SafeParser.Parser any a"},{"name":"or","comment":" Use this if you need to add a `ZeroOrMore` parser as the final alternative\nat the end of a `oneOf` list. By ensuring that only the _last_ alternative\nparser can be `ZeroOrMore`, this prevents you from accidentally creating parsers\nwhere some of the alternatives are unreachable.\n\n    import SafeParser as SP\n\n    type NullableBool\n        = Boolean Bool\n        | Null\n\n    nullableBool : SP.Parser oneOrMore NullableBool\n    nullableBool =\n        SP.oneOf\n            [ SP.symbol \"true\" |> SP.map (\\_ -> Boolean True)\n            , SP.symbol \"false\" |> SP.map (\\_ -> Boolean False)\n            ]\n            |> SP.or (SP.symbol \"null\" |> SP.map (\\_ -> Null))\n\n\n    SP.run nullableBool \"true\" --> Ok (Boolean True)\n    SP.run nullableBool \"null\" --> Ok (Null)\n\n","type":"SafeParser.Parser any a -> SafeParser.Parser SafeParser.OneOrMore a -> SafeParser.Parser any a"},{"name":"problem","comment":" Indicate that a parser has reached a dead end. \"Everything was going fine\nuntil I ran into this problem.\" Check out the `andThen` docs to see an example\nusage.\n","type":"String.String -> SafeParser.Parser any a"},{"name":"run","comment":" Run a `Parser` over a string. This is exactly like `elm/parser`'s `run`.\n","type":"SafeParser.Parser any a -> String.String -> Result.Result (List.List Parser.DeadEnd) a"},{"name":"skip0","comment":" Skip values produced by a `ZeroOrMore` parser in a parser pipeline.\n\nSee docs for [`skip1`](#skip1).\n\n","type":"SafeParser.Parser SafeParser.ZeroOrMore skip -> SafeParser.Parser any keep -> SafeParser.Parser any keep"},{"name":"skip1","comment":" Skip values produced by a `OneOrMore` parser in a parser pipeline.\n\nFor example, maybe we want to parse some JavaScript variables:\n\n    import SafeParser as SP\n\n    var : SP.Parser oneOrMore String\n    var =\n        SP.succeed ()\n            |> SP.skip1 (SP.chompIf isStartChar)\n            |> SP.skip0 (SP.chompWhile isInnerChar)\n            |> SP.getChompedString\n\n    isStartChar : Char -> Bool\n    isStartChar char =\n        Char.isAlpha char || char == '_' || char == '$'\n\n    isInnerChar : Char -> Bool\n    isInnerChar char =\n        isStartChar char || Char.isDigit char\n\n    SP.run var \"$hello\" --> Ok \"$hello\"\n\n`chompIf isStartChar` can chomp one character and produce a `()` value.\n`chompWhile isInnerChar` can chomp zero or more characters and produce a `()`\nvalue. The `skip1`/`skip0` functions are saying to still chomp all the\ncharacters, but skip the two `()` values that get produced. No one cares about\nthem.\n\n","type":"SafeParser.Parser SafeParser.OneOrMore skip -> SafeParser.Parser any keep -> SafeParser.Parser oneOrMore keep"},{"name":"spaces","comment":" Parse zero or more ' ', '\\\\n', and '\\\\r' characters.\n\nThe implementation is pretty simple:\n\n    import SafeParser as SP\n\n    spaces : SP.Parser SP.ZeroOrMore ()\n    spaces =\n        SP.chompWhile (\\c -> c == ' ' || c == '\\n' || c == '\\u{000D}')\n\n    SP.run spaces \"  \\n\" --> Ok ()\n    SP.run spaces \"\" --> Ok ()\n    SP.run spaces \"xxx\" --> Ok ()\n\nNote that as a `ZeroOrMore` parser, `spaces` will alway succeed.\n\n","type":"SafeParser.Parser SafeParser.ZeroOrMore ()"},{"name":"succeed","comment":" A parser that succeeds without chomping any characters.\n\n    import SafeParser as SP\n\n    SP.run (SP.succeed 90210  ) \"mississippi\" --> Ok 90210\n    SP.run (SP.succeed 3.141  ) \"mississippi\" --> Ok 3.141\n    SP.run (SP.succeed ()     ) \"mississippi\" --> Ok ()\n    SP.run (SP.succeed Nothing) \"mississippi\" --> Ok Nothing\n\nSeems weird on its own, but it is very useful in combination with other\nfunctions. The docs for `keep1` and `andThen` have some neat examples.\n\n","type":"a -> SafeParser.Parser SafeParser.ZeroOrMore a"},{"name":"symbol","comment":" Parse symbols like `(` and `,`.\n\n    import SafeParser as SP\n    import Parser\n\n    SP.run (SP.symbol \"[\") \"[\"\n    --> Ok ()\n\n    SP.run (SP.symbol \"[\") \"4\"\n    --> Err [ { row = 1, col = 1, problem = Parser.ExpectingSymbol \"[\" } ]\n\n    SP.run (SP.symbol \"\") \"whatever\"\n    --> Err [ { row = 1, col = 1, problem = Parser.Problem \"The `symbol` parser cannot match an empty string\" } ]\n\n**Note:** unlike the `elm/parser` version of this function, `symbol` will always\nfail if asked to match an empty string.\n\n","type":"String.String -> SafeParser.Parser oneOrMore ()"},{"name":"toElmParser","comment":" Convert a `Parser` from this package to `elm/parser`'s `Parser` type.\n\nThis will lose type safety, but might be useful if you need to interoperate with\nother Elm parser libraries like `dmy/elm-pratt-parser`.\n\n","type":"SafeParser.Parser any a -> Parser.Parser a"},{"name":"token","comment":" Parse exactly the given `String`, without caring what comes next.\n\nHere is how you could use `token` to implement `keyword`:\n\n    import SafeParser as SP\n    import Parser\n\n    keyword : String -> SP.Parser oneOrMore ()\n    keyword kwd =\n        SP.succeed identity\n            |> SP.skip1 (SP.backtrackable (SP.token kwd))\n            |> SP.keep0\n                (SP.map (\\_ -> True) (SP.backtrackable (SP.chompIf isVarChar))\n                    |> SP.or (SP.succeed False)\n                )\n            |> SP.andThen10 (checkEnding kwd)\n\n    checkEnding : String -> Bool -> SP.Parser SP.ZeroOrMore ()\n    checkEnding kwd isBadEnding =\n        if isBadEnding then\n            SP.problem (\"expecting the `\" ++ kwd ++ \"` keyword\")\n        else\n            SP.commit ()\n\n    isVarChar : Char -> Bool\n    isVarChar char =\n        Char.isAlphaNum char || char == '_'\n\n    SP.run (SP.token \"hello\") \"helloWorld\"\n    --> Ok ()\n\n    SP.run (SP.token \"\") \"whatever\"\n    --> Err [ { row = 1, col = 1, problem = Parser.Problem \"The `token` parser cannot match an empty string\" } ]\n\n**Note:** unlike the `elm/parser` version of this function, `token` will always\nfail if asked to match an empty string.\n\n","type":"String.String -> SafeParser.Parser oneOrMore ()"},{"name":"variable","comment":" Create a parser for variables. If we wanted to parse type variables in Elm,\nwe could try something like this:\n\n    import SafeParser as SP\n    import Set\n    import Parser as P\n\n    typeVar : SP.Parser oneOrMore String\n    typeVar =\n        SP.variable\n            { start = Char.isLower\n            , inner = \\c -> Char.isAlphaNum c || c == '_'\n            , reserved = Set.fromList [ \"let\", \"in\", \"case\", \"of\" ]\n            }\n\n    SP.run typeVar \"abc\" --> Ok \"abc\"\n    SP.run typeVar \"Abc\" --> Err [ { col = 1, problem = P.ExpectingVariable, row = 1 } ]\n    SP.run typeVar \"let\" --> Err [ { col = 1, problem = P.ExpectingVariable, row = 1 } ]\n\nThis is saying it must start with a lower-case character. After that, characters\ncan be letters, numbers, or underscores. It is also saying that if you run into\nany of these reserved names, it is definitely not a variable.\n\n","type":"{ start : Char.Char -> Basics.Bool, inner : Char.Char -> Basics.Bool, reserved : Set.Set String.String } -> SafeParser.Parser oneOrMore String.String"}],"binops":[]}]