[{"name":"SafeParser","comment":"\n\n\n## Running parsers\n\n@docs Parser, run\n\n\n## Chomping inputs\n\n@docs OneOrMore, ZeroOrMore, chompIf, chompWhile, getChompedString\n\n\n## Generally useful parsers\n\n@docs symbol\n\n\n## Succeeding and failing\n\n@docs succeed, problem\n\n\n## Combining parsers\n\n@docs keep1, keep0, skip1, skip0\n\n\n## Choosing parsers\n\n@docs or, backtrackable\n\n\n## Transforming parsers\n\n@docs map, andThen00, andThen10, andThen01\n\n\n## Looping parsers\n\n@docs Step, continue, done, loop\n\n","unions":[{"name":"OneOrMore","comment":" A phantom type indicating that a `Parser` is guaranteed to chomp at least\none character when it succeeds.\n","args":[],"cases":[]},{"name":"Parser","comment":" Very similar to `elm/parser`'s `Parser` type, but with an extra phantom type\nvariable that allows us to track and propagate information about whether the\nparser is guaranteed to chomp characters when it succeeds.\n","args":["any","a"],"cases":[]},{"name":"ZeroOrMore","comment":" A phantom type indicating that a `Parser` might succeed without chomping any\ncharacters.\n","args":[],"cases":[]}],"aliases":[{"name":"Step","comment":" Instead of directly exposing the `elm/parser` constructors for `Step`\n(`Loop` and `Done`), we provide two functions, `continue` and `done` that are\nequivalent to `map Loop` and `map Done`.\n","args":["state","a"],"type":"Parser.Step state a"}],"values":[{"name":"andThen00","comment":" Like [`elm/parser`'s\n`andThen`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#andThen).\nGo read those docs!\n\n`andThen00` is used when the parser returned by the callback in the first\nargument is `ZeroOrMore`, and the parser passed as the second argument is _also_\n`ZeroOrMore`. Since neither of these parsers is guaranteed to chomp any\ncharacters, `andThen00` returns a `ZeroOrMore` parser.\n\n","type":"(a -> SafeParser.Parser SafeParser.ZeroOrMore b) -> SafeParser.Parser SafeParser.ZeroOrMore a -> SafeParser.Parser SafeParser.ZeroOrMore b"},{"name":"andThen01","comment":" Like [`elm/parser`'s\n`andThen`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#andThen).\nGo read those docs!\n\n`andThen01` is used when the parser that results from the callback in the first\nargument is `OneOrMore`. This guarantees that if the parser succeeds, it must\nchomp one or more characters, so `andThen10` can return a `OneOrMore` parser.\n\n","type":"(a -> SafeParser.Parser SafeParser.OneOrMore b) -> SafeParser.Parser any a -> SafeParser.Parser oneOrMore b"},{"name":"andThen10","comment":" Like [`elm/parser`'s\n`andThen`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#andThen).\nGo read those docs!\n\n`andThen10` is used when the parser passed as the second argument is\n`OneOrMore`. This guarantees that if the parser succeeds, it must chomp one or\nmore characters, so `andThen10` can return a `OneOrMore` parser.\n\n","type":"(a -> SafeParser.Parser any b) -> SafeParser.Parser SafeParser.OneOrMore a -> SafeParser.Parser oneOrMore b"},{"name":"backtrackable","comment":" Like [`elm/parser`'s\n`backtrackable`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#backtrackable).Go\nread those docs!\n","type":"SafeParser.Parser any a -> SafeParser.Parser any a"},{"name":"chompIf","comment":" Chomp one character if it passes the test.\n\n    import SafeParser exposing (Parser, chompIf, run)\n\n    chompUpper : Parser oneOrMore ()\n    chompUpper =\n        chompIf Char.isUpper\n\n    run chompUpper \"T\" --> Ok ()\n\nSo this can chomp a character like `\"T\"` and produces a `()` value.\n\n","type":"(Char.Char -> Basics.Bool) -> SafeParser.Parser oneOrMore ()"},{"name":"chompWhile","comment":" Chomp zero or more characters if they pass the test. This is commonly\nuseful for chomping whitespace or variable names:\n\n    import SafeParser exposing (Parser, ZeroOrMore, chompIf, chompWhile, getChompedString, succeed, keep1, skip0, run)\n\n    whitespace : Parser ZeroOrMore ()\n    whitespace =\n        chompWhile (\\c -> c == ' ' || c == '\\t' || c == '\\n' || c == '\\u{000D}')\n\n    elmVar : Parser oneOrMore String\n    elmVar =\n        succeed identity\n            |> keep1 (chompIf Char.isLower)\n            |> skip0 (chompWhile (\\c -> Char.isAlphaNum c || c == '_'))\n            |> getChompedString\n\n    run elmVar \"helloWorld\" --> Ok \"helloWorld\"\n\nNote: a `chompWhile` parser always succeeds!\n\n","type":"(Char.Char -> Basics.Bool) -> SafeParser.Parser SafeParser.ZeroOrMore ()"},{"name":"continue","comment":" Ensure that any parser that is going to continue looping is always going to\nchomp something if it succeeds. This makes it impossible to fall into infinite\nloops.\n","type":"SafeParser.Parser SafeParser.OneOrMore state -> SafeParser.Parser any (SafeParser.Step state a)"},{"name":"done","comment":" For parsers that end a loop, it doesn't matter if they chomp or not - either\nway, there's no risk of an infinite loop. So you can pass any parser to `done`.\n","type":"SafeParser.Parser any a -> SafeParser.Parser any (SafeParser.Step state a)"},{"name":"getChompedString","comment":" Sometimes parsers like int or variable cannot do exactly what you need. The\n\"chomping\" family of functions is meant for that case! Maybe you need to parse\nvalid PHP variables like $x and $txt:\n\n    import SafeParser exposing (Parser, chompIf, chompWhile, getChompedString, succeed, skip1, skip0, run)\n\n    php : Parser oneOrMore String\n    php =\n        succeed ()\n            |> skip1 (chompIf (\\c -> c == '$'))\n            |> skip1 (chompIf (\\c -> Char.isAlpha c || c == '_'))\n            |> skip0 (chompWhile (\\c -> Char.isAlphaNum c || c == '_'))\n            |> getChompedString\n\n    run php \"$my_var\" --> Ok \"$my_var\"\n\nThe idea is that you create a bunch of chompers that validate the underlying\ncharacters. Then getChompedString extracts the underlying String efficiently.\n\n","type":"SafeParser.Parser any a -> SafeParser.Parser any String.String"},{"name":"keep0","comment":" Keep values produced by a `ZeroOrMore` parser in a parser pipeline.\n\nSee docs for [`keep1`](#keep1).\n\n","type":"SafeParser.Parser SafeParser.ZeroOrMore a -> SafeParser.Parser any (a -> b) -> SafeParser.Parser any b"},{"name":"keep1","comment":" Keep values produced by a `OneOrMore` parser in a parser pipeline.\n\nFor example, we could say:\n\n    import SafeParser exposing (OneOrMore, Parser, andThen10, chompIf, chompWhile, getChompedString, keep1, keep0, problem, skip0, succeed, symbol, run)\n\n    type alias Point =\n        { x : Int, y : Int }\n\n    int : Parser OneOrMore Int\n    int =\n        succeed (++)\n            |> keep1\n                (chompIf Char.isDigit\n                    |> getChompedString\n                )\n            |> keep0\n                (chompWhile Char.isDigit\n                    |> getChompedString\n                )\n            |> andThen10\n                (\\str ->\n                    case String.toInt str of\n                        Just n ->\n                            succeed n\n\n                        Nothing ->\n                            problem \"not an int\"\n                )\n\n    point : Parser OneOrMore Point\n    point =\n        succeed Point\n            |> skip0 (symbol \"(\")\n            |> keep1 int\n            |> skip0 (symbol \",\")\n            |> keep1 int\n            |> skip0 (symbol \")\")\n\n    run point \"(123,456)\" --> Ok { x = 123, y = 456 }\n\nAll the parsers in the `point` pipeline will chomp characters and produce\nvalues. So `symbol \"(\"` will chomp one paren and produce a `()` value.\nSimilarly, `int` will chomp some digits and produce an `Int` value. The\n`keep1`/`keep0` and `skip1`/`skip0` functions just decide whether we give the\nvalues to the Point function.\n\nSo in this case, we skip the `()` from `symbol \"(\"`, we keep the `Int` from\n`int`, etc.\n\n","type":"SafeParser.Parser SafeParser.OneOrMore a -> SafeParser.Parser any (a -> b) -> SafeParser.Parser oneOrMore b"},{"name":"loop","comment":" Run the first callback with the initial state and if it succeeds, either\ncontinue the loop or return a value. If the first callback fails, run the second\ncallback and either continue or return a value.\n\n    import SafeParser exposing (loop, chompIf, continue, or, succeed, done, getChompedString, run)\n\n    digits =\n        loop\n            ()\n            (\\state ->\n                (chompIf Char.isDigit |> continue)\n                    |> or (succeed () |> done)\n            )\n            |> getChompedString\n\n    run digits \"1234abc\" --> Ok \"1234\"\n","type":"state -> (state -> SafeParser.Parser any (SafeParser.Step state a)) -> SafeParser.Parser any a"},{"name":"map","comment":" Like [`elm/parser`'s\n`map`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#map). Go\nread those docs!\n","type":"(a -> b) -> SafeParser.Parser any a -> SafeParser.Parser any b"},{"name":"or","comment":" Use this instead of `elm/parser`'s `oneOf` to try a bunch of parsers and go\nwith the first one that succeeds.\n\nOnly the _last_ parser passed to a pipeline of `or`s can be a `ZeroOrMore`\nparser. This prevents you from accidentally creating pipelines where some of the\nparsers are unreachable.\n\n    import SafeParser exposing (Parser, or, map, symbol, run)\n\n    type NullableBool\n        = Boolean Bool\n        | Null\n\n    nullableBool : Parser oneOrMore NullableBool\n    nullableBool =\n        (map (\\_ -> Boolean True) (symbol \"true\"))\n            |> or (map (\\_ -> Boolean False) (symbol \"false\"))\n            |> or (map (\\_ -> Null) (symbol \"null\"))\n\n    run nullableBool \"true\" --> Ok (Boolean True)\n    run nullableBool \"null\" --> Ok (Null)\n\n","type":"SafeParser.Parser any a -> SafeParser.Parser SafeParser.OneOrMore a -> SafeParser.Parser any a"},{"name":"problem","comment":" Indicate that a parser has reached a dead end. \"Everything was going fine\nuntil I ran into this problem.\" Check out the `andThen` docs to see an example\nusage.\n","type":"String.String -> SafeParser.Parser SafeParser.ZeroOrMore a"},{"name":"run","comment":" Run a `Parser` over a string. This is exactly like `elm/parser`'s `run`.\n","type":"SafeParser.Parser any a -> String.String -> Result.Result (List.List Parser.DeadEnd) a"},{"name":"skip0","comment":" Skip values produced by a `ZeroOrMore` parser in a parser pipeline.\n\nSee docs for [`skip1`](#skip1).\n\n","type":"SafeParser.Parser SafeParser.ZeroOrMore skip -> SafeParser.Parser any keep -> SafeParser.Parser any keep"},{"name":"skip1","comment":" Skip values produced by a `OneOrMore` parser in a parser pipeline.\n\nFor example, maybe we want to parse some JavaScript variables:\n\n    import SafeParser exposing (Parser, chompIf, chompWhile, getChompedString, succeed, skip1, skip0, run)\n\n    var : Parser oneOrMore String\n    var =\n        succeed ()\n            |> skip1 (chompIf isStartChar)\n            |> skip0 (chompWhile isInnerChar)\n            |> getChompedString\n\n    isStartChar : Char -> Bool\n    isStartChar char =\n        Char.isAlpha char || char == '_' || char == '$'\n\n    isInnerChar : Char -> Bool\n    isInnerChar char =\n        isStartChar char || Char.isDigit char\n\n    run var \"$hello\" --> Ok \"$hello\"\n\n`chompIf isStartChar` can chomp one character and produce a `()` value.\n`chompWhile isInnerChar` can chomp zero or more characters and produce a `()`\nvalue. The `skip1`/`skip0` functions are saying to still chomp all the\ncharacters, but skip the two `()` values that get produced. No one cares about\nthem.\n\n","type":"SafeParser.Parser SafeParser.OneOrMore skip -> SafeParser.Parser any keep -> SafeParser.Parser oneOrMore keep"},{"name":"succeed","comment":" A parser that succeeds without chomping any characters.\n\n    import SafeParser exposing (run, succeed)\n\n    run (succeed 90210  ) \"mississippi\" --> Ok 90210\n    run (succeed 3.141  ) \"mississippi\" --> Ok 3.141\n    run (succeed ()     ) \"mississippi\" --> Ok ()\n    run (succeed Nothing) \"mississippi\" --> Ok Nothing\n\nSeems weird on its own, but it is very useful in combination with other\nfunctions. The docs for `keep1` and `andThen` have some neat examples.\n\n","type":"a -> SafeParser.Parser SafeParser.ZeroOrMore a"},{"name":"symbol","comment":" Parse symbols like `(` and `,`.\n\n    import SafeParser exposing (symbol, run)\n    import Parser\n\n    run (symbol \"[\") \"[\"\n    --> Ok ()\n\n    run (symbol \"[\") \"4\"\n    --> Err [ { row = 1, col = 1, problem = Parser.ExpectingSymbol \"[\" } ]\n\n    run (symbol \"\") \"whatever\"\n    --> Err [ { row = 1, col = 1, problem = Parser.Problem \"The `symbol` parser cannot match an empty string\" } ]\n\n**Note:** unlike the `elm/parser` version of this function, `symbol` will always\nfail if asked to match an empty string.\n\n","type":"String.String -> SafeParser.Parser alwayChomps ()"}],"binops":[]}]